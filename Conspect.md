Теория категорий, типизация и функциональное программирование
+ Взгляд на теорию функционального программирования на основе очень абстрактного математического понятия
+ Изучает взаимосвязь понятий без привязки к их внутренней структуре
+ Применяется в: 
    - Топологии
    - Теоретической физике
    - Информатике

Категории
Определение - это семейство объектов Ob(K), и семейство морфизмов ("стрелок") Mor(K)
- ∀ f : A → B, g: B → C  $\exists$ g $\circ$ f : A → C (композиция)
- ∀ A ∈ Ob(K), $\exists$ Id$_{A}$: A → A (единичная стрелка)
- ∀ f, g, h ∈ Mor(K): (f $\circ$ g) $\circ$ h = f $\circ$ (g $\circ$ h) (ассоциативность)
- ∀ f : A → B имеет место f $\circ$ Id$_{A}$ = Id$_{B}$ $\circ$ f = f (свойство единицы)

// TODO: картиночка

Примеры категорий:
+ Категория из одного объекта
+ Граф пораждает категории
+ Отношение порядка пораждает категорию
+ Категория всех множеств Set (каждый объект множество, "стрелки" - функции)
+ Категория всех типов\функций ЯП (надо рассматривать возможную незавершимость функций)

Двойственные категории - такие категории, что "стрелки" повернули наоборот. Удобны для доказательств (по двойственности... ).
+ Ob(K) = Ob($K_{duo}$)
+ ∀ f : A → B ∈ Mor(K), $\exist$f: B → A  ∈ Mor($K_{duo}$)

Начальный и терминальный объект
- $A \in Ob(K)$ - начальный объект, если $\forall B \in Ob(K) \ \exists ! f : A \rightarrow B$ 
    + Из него идут стрелки во все другие объекты
- $A \in Ob(K)$ - терминальный объект, если $\forall B \in Ob(K) \ \exists ! f : B \rightarrow A$ 
    + из каждого объекта сюда приходит одна стрелка

Пример начальные и терминальные объекты в Set:
+ absurd: void $\rightarrow$ 't - начальный
+ unit: `let Unit _ = ()`

Функторы

- Функтор $F$ – это отображение двух категорий $K_1$ и $K_2$
- Функтор должен сохранять свойства композиции
- $F : Ob(K_1) \rightarrow Ob(K_2)$
- $F : Mor(K_1) \rightarrow Mor(K_2)$

Свойства:
- $F(Id_A) = Id_{F(A)}$
- Если $f : A \rightarrow B$, то $F \ f : F(A) \rightarrow F(B)$
- $F(f \circ g) = F(f) \circ F(g)$

<details>
<summary>Примеры некоторых функторов</summary>
Конструктор : `fmap: (a->b) -> (F a -> F b)`

Some: 
```fsharp
let fmap f = function 
    | None -> None
    | Some(x) -> Some(f x)
```

[]: 
```fsharp
List.map
```

Дерево типа t: 
```fsharp
Tree Map
```
</details>

Функтор отображающий категорию в саму в себя, называется <u><b>эндофунктором</u></b>

Функтор Some на f#:
```fsharp
let fmap f = function
    | None -> None
    | Some(x) -> Some(f x)

fmap ((+) 1) (Some 10)

let ($) f x = fmap f x // производит лифтинг?
(+) 1 $ Some(10) 

```
Лифтинг - подъём на уровень функтора (5 -> 6 : Some(5) -> Some(6)). Те повышение абстрактности.

Аппликативные функторы - функторы, для которых мы рассматриваем исходные фукнкции в пространстве функторного типа

```fsharp
let (<*>) f x = // example
    match f, x with
        | None, _ -> None
        | _, None -> None
        | Some(f), Some(x) -> Some(f x)

(Some (+)) <*> Some(1) <*> Some(2) // Some 3
```
`Some((+))` - можно записать как функцию `Pure(f)`, которая будет поднимать функции

```fsharp
let (<!>) a b =
    let mas = (fun f -> List.map f b) // для другой функции на вход, вернёт список, где для каждого элемента применит входную функцию
    let first = List.map mas a // применим для списка a
    first |> List.concat 

let res = [(+)1;(-)1] <!> [1;2]
printfn "%A" res

let pure f = [f]
pure (+) <!> [1..2] <!> [3..4]
```

Задача. Надо расставить знаки(+,-,\*) между числами в списке, и посчитать все возможные значения. `[1;2] -> [1*2;1-2;1+2]`

```fsharp
let rec split = function
    | [x] -> []
    | h::t -> ([h], t)::(List.map (fun (a, b) -> (h::a, b)) (split t))

split([1..10])

// все варианты расстановки знаков между числами в списке
let rec values = function
    | [] -> []
    | [x] -> [x]
    | Lst -> 
        let variats = split Lst
        let res = List.map (fun (l, r) -> [(+);(-);(*)] <!> (values l) <!> (values r)) variants
        List.distinct (List.concat res)

```

Произведения и ко-произведения.
### Категориальное определение пары

- Произведение $A, B \in Ob(K)$ это:
  - Объект $C \in Ob(K)$
  - Пара стрелок $\text{fst}: C \rightarrow A$, $\text{snd}: C \rightarrow B$ (проекции)

- При этом $\forall D \in Ob(K)$ и $g_1 : C \rightarrow A$, $g_2 : C \rightarrow B$ $\exists ! f : D \rightarrow C$

- В категории Set произведение – это $A \times B$

*Произведение определяется с точностью до изоморфизма*

Алгебраические типы данных можно определять на основе произведения и суммы. 
Например
|Значение|Тип|
|---|---|
|1|()|
|a + b|Either a b = Left a | Right b|
|a * b|(a, b)|
|2 = 1 + 1|type Bool = True | False|
|1 + a|type 't option = None | Some 't|
|0 * a|(Void, 'a)|
|a \* (b + c) = a \* b +a \* c| ('a, Left 'b \| Right 'c) = Left ('a, 'b) \| Right('a, 'c)|
|1 + 't * x|list<'t> = Nil \| Const 't * list<'t>|

Монады.
>Монады это моноид в категории эндофункторов
Монады позволяют описать цепочку операций, где что то может пойти не так

```fsharp
let good x = Some(x+1)
let bad x = None

let (>>=) x f = 
    match x with
        | Some(z) -> f z
        | None -> None

Some(1) >>= good // Some(2)
Some(1) >>= bad  >>= good // None
```

Те это такая штука, которая за нас обработает данные, если они станут плохими в какой то момент, убирая большую вложенность блоков `if-else`
Математически называется категория Клейси(>=>(fish operator)), отличие с bind(>>=), что на вход уже подаётся обёрнутое значение.

Сравнение 
|Название|Функция|
|---|---|
|Функтор|`fmap (a->b) -> F a -> F b`|
|Аппликативный функтор|`<*> : F (a -> b) -> F a -> F b` <br>`pure f : (a -> b) -> F(a -> b)`|
|Монада|`>>= : M a -> (a -> M b) -> M b` <br>`>=> : (a -> M b) -> (b -> M c) -> (a -> M c)` <br> `return: a -> M a`|

Оптика - набор функциональных абстракций позволяющих работать со сложными структурами данных
Линзы решают задачу выделения конкретного места в какой-то структуре данных